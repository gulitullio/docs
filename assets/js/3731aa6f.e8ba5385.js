"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[787],{2433:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"principi-fontamentali/oop/incapsulamento","title":"Incapsulamento","description":"Consiste nel nascondere i dettagli interni di un oggetto e nell\'esporre solo ci\xf2 che \xe8 necessario tramite metodi o propriet\xe0.","source":"@site/content/principi-fontamentali/oop/incapsulamento.md","sourceDirName":"principi-fontamentali/oop","slug":"/principi-fontamentali/oop/incapsulamento","permalink":"/docs/docs/principi-fontamentali/oop/incapsulamento","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/content/principi-fontamentali/oop/incapsulamento.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Incapsulamento","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"OOP","permalink":"/docs/docs/principi-fontamentali/oop/"},"next":{"title":"Ereditariet\xe0","permalink":"/docs/docs/principi-fontamentali/oop/ereditariet\xe0"}}');var o=t(4848),a=t(8453);const r={title:"Incapsulamento",sidebar_position:1},s=void 0,c={},l=[{value:"Esempio in C# - Personaggio di un gioco",id:"esempio-in-c---personaggio-di-un-gioco",level:2}];function p(e){const n={br:"br",code:"code",h2:"h2",hr:"hr",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["Consiste nel ",(0,o.jsx)(n.strong,{children:"nascondere i dettagli interni di un oggetto"})," e nell'esporre solo ci\xf2 che \xe8 necessario tramite metodi o propriet\xe0.",(0,o.jsx)(n.br,{}),"\n","Questo permette di proteggere lo stato interno dell'oggetto e di controllarne l'accesso e la modifica."]}),"\n",(0,o.jsx)(n.p,{children:"Nei videogames, ad esempio, gli oggetti come personaggi, nemici o oggetti di gioco spesso hanno stati interni che non devono essere modificati arbitrariamente (es. salute, energia, munizioni). L'incapsulamento permette di garantire che queste variabili vengano modificate solo in modi controllati, mantenendo la coerenza dello stato di gioco."}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"esempio-in-c---personaggio-di-un-gioco",children:"Esempio in C# - Personaggio di un gioco"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cs",children:'public class Character\r\n{\r\n    // Qui vediamo che il campo \xe8 privato\r\n    // Questo perch\xe9 vogliamo accedervi solo con i metodi TakeDamage o Heal\r\n    private int health;\r\n\r\n    public int Health {\r\n        get { return health; }\r\n        private set {\r\n            if (value < 0) health = 0;\r\n            else if (value > MaxHealth) health = MaxHealth;\r\n            else health = value;\r\n        }\r\n    }\r\n\r\n    public int MaxHealth { get; private set; }\r\n\r\n    public Character(int initialHealth, int maxHealth) {\r\n        MaxHealth = maxHealth;\r\n        Health = initialHealth;\r\n    }\r\n\r\n    public void TakeDamage(int damage) {\r\n        if (damage < 0) throw new ArgumentException("Damage cannot be negative.");\r\n\r\n        Health -= damage;\r\n        if (Health == 0) Console.WriteLine("Character is dead!");\r\n    }\r\n\r\n    public void Heal(int amount) {\r\n        if (amount < 0) throw new ArgumentException("Healing amount cannot be negative.");\r\n\r\n        Health += amount;\r\n    }\r\n}\n'})})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var i=t(6540);const o={},a=i.createContext(o);function r(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);