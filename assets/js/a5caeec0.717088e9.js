"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2266],{1158:(i,o,e)=>{e.r(o),e.d(o,{assets:()=>a,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"algoritmi/collision-resolution","title":"Collision resolution","description":"In ambito gaming e simulazioni, quando due o pi\xf9 oggetti si scontrano (collision detection), serve una logica per gestire cosa succede dopo: questo processo si chiama collision resolution.","source":"@site/content/algoritmi/collision-resolution.md","sourceDirName":"algoritmi","slug":"/algoritmi/collision-resolution","permalink":"/docs/content/algoritmi/collision-resolution","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/content/algoritmi/collision-resolution.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Collision resolution","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Collision detection","permalink":"/docs/content/algoritmi/collision-detection"},"next":{"title":"Pathfinding","permalink":"/docs/content/algoritmi/pathfinding"}}');var l=e(4848),t=e(8453);const r={title:"Collision resolution",sidebar_position:2},s=void 0,a={},c=[{value:"Tipi comuni di Collision Resolution",id:"tipi-comuni-di-collision-resolution",level:3},{value:"Esempio",id:"esempio",level:3}];function p(i){const o={code:"code",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...i.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(o.p,{children:"In ambito gaming e simulazioni, quando due o pi\xf9 oggetti si scontrano (collision detection), serve una logica per gestire cosa succede dopo: questo processo si chiama collision resolution."}),"\n",(0,l.jsx)(o.p,{children:"In pratica, la collision resolution risponde a domande tipo:"}),"\n",(0,l.jsxs)(o.ul,{children:["\n",(0,l.jsx)(o.li,{children:"Come devo spostare gli oggetti per evitare che restino incastrati?"}),"\n",(0,l.jsx)(o.li,{children:"Come calcolo la risposta fisica (rimbalzo, attrito, ecc)?"}),"\n",(0,l.jsx)(o.li,{children:"Quale comportamento devo applicare in base al tipo di oggetto (muro, nemico, power-up)?"}),"\n"]}),"\n",(0,l.jsx)(o.p,{children:"Senza un\u2019adeguata collision resolution, le collisioni sarebbero solo rilevate ma non risolte, quindi:"}),"\n",(0,l.jsxs)(o.ul,{children:["\n",(0,l.jsx)(o.li,{children:"Oggetti potrebbero sovrapporsi (clipping)"}),"\n",(0,l.jsx)(o.li,{children:"Personaggi potrebbero passare attraverso muri"}),"\n",(0,l.jsx)(o.li,{children:"L\u2019esperienza di gioco sarebbe incoerente o frustrante"}),"\n"]}),"\n",(0,l.jsx)(o.hr,{}),"\n",(0,l.jsx)(o.h3,{id:"tipi-comuni-di-collision-resolution",children:"Tipi comuni di Collision Resolution"}),"\n",(0,l.jsxs)(o.ul,{children:["\n",(0,l.jsxs)(o.li,{children:[(0,l.jsx)(o.strong,{children:"Separazione Posizionale"}),": Spostare gli oggetti fuori dalla collisione"]}),"\n",(0,l.jsxs)(o.li,{children:[(0,l.jsx)(o.strong,{children:"Impulse-based"}),": Applicare un impulso per simulare rimbalzi"]}),"\n",(0,l.jsxs)(o.li,{children:[(0,l.jsx)(o.strong,{children:"Penetration Depth"}),": Calcolare la profondit\xe0 di sovrapposizione e correggerla"]}),"\n",(0,l.jsxs)(o.li,{children:[(0,l.jsx)(o.strong,{children:"Continuous Collision Resolution"}),": Usata per oggetti veloci per evitare di \u201csaltare\u201d attraverso collider"]}),"\n"]}),"\n",(0,l.jsx)(o.hr,{}),"\n",(0,l.jsx)(o.h3,{id:"esempio",children:"Esempio"}),"\n",(0,l.jsx)(o.p,{children:"Supponiamo di voler gestire la collisione di un player con un muro usando un semplice metodo di separazione posizionale."}),"\n",(0,l.jsxs)(o.ul,{children:["\n",(0,l.jsx)(o.li,{children:"Alla collisione, otteniamo il punto di contatto e la normale della superficie del muro"}),"\n",(0,l.jsx)(o.li,{children:"Calcoliamo la penetrazione come proiezione del punto di contatto sulla normale"}),"\n",(0,l.jsx)(o.li,{children:"Spostiamo il player lungo quella direzione per risolvere la sovrapposizione"}),"\n",(0,l.jsx)(o.li,{children:"Cambiamo la velocit\xe0 riflettendola sulla normale per simulare un piccolo rimbalzo"}),"\n"]}),"\n",(0,l.jsx)(o.pre,{children:(0,l.jsx)(o.code,{className:"language-csharp",children:"public class SimpleCollisionResolution : MonoBehaviour\r\n{\r\n    public Rigidbody2D rb;\r\n    public Collider2D playerCollider;\r\n\r\n    void OnCollisionEnter2D(Collision2D collision)\r\n    {\r\n        // Prendiamo il primo punto di contatto\r\n        ContactPoint2D contact = collision.contacts[0];\r\n\r\n        // Direzione di separazione: il normale al punto di contatto\r\n        Vector2 separationDirection = contact.normal;\r\n\r\n        // Profondit\xe0 di penetrazione (stimata)\r\n        float penetrationDepth = Mathf.Abs(Vector2.Dot(contact.point - (Vector2)rb.position, separationDirection));\r\n\r\n        // Spostiamo il player fuori dal muro\r\n        rb.position += separationDirection * penetrationDepth;\r\n\r\n        // Facciamo rimbalzare leggermente il player all'indietro\r\n        Vector2 velocity = rb.velocity;\r\n        velocity = Vector2.Reflect(velocity, separationDirection) * 0.5f; // dimezziamo la velocit\xe0 per simulare attrito\r\n        rb.velocity = velocity;\r\n    }\r\n}\n"})})]})}function d(i={}){const{wrapper:o}={...(0,t.R)(),...i.components};return o?(0,l.jsx)(o,{...i,children:(0,l.jsx)(p,{...i})}):p(i)}},8453:(i,o,e)=>{e.d(o,{R:()=>r,x:()=>s});var n=e(6540);const l={},t=n.createContext(l);function r(i){const o=n.useContext(t);return n.useMemo(function(){return"function"==typeof i?i(o):{...o,...i}},[o,i])}function s(i){let o;return o=i.disableParentContext?"function"==typeof i.components?i.components(l):i.components||l:r(i.components),n.createElement(t.Provider,{value:o},i.children)}}}]);