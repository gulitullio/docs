"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8751],{5008:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>o});const a=JSON.parse('{"id":"languages/c-plus-plus/heap-and-stack","title":"Heap & Stack","description":"---","source":"@site/content/languages/c-plus-plus/heap-and-stack.md","sourceDirName":"languages/c-plus-plus","slug":"/languages/c-plus-plus/heap-and-stack","permalink":"/docs/content/languages/c-plus-plus/heap-and-stack","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/content/languages/c-plus-plus/heap-and-stack.md","tags":[],"version":"current","frontMatter":{"title":"Heap & Stack"},"sidebar":"tutorialSidebar","previous":{"title":"Ereditariet\xe0","permalink":"/docs/content/languages/c-plus-plus/ereditariet\xe0"},"next":{"title":"Keyword Auto","permalink":"/docs/content/languages/c-plus-plus/keyword-auto"}}');var l=n(4848),t=n(8453);const s={title:"Heap & Stack"},r=void 0,c={},o=[{value:"Differenze chiave",id:"differenze-chiave",level:2},{value:"Stack",id:"stack",level:2},{value:"Caratteristiche principali",id:"caratteristiche-principali",level:3},{value:"Esempio",id:"esempio",level:3},{value:"Heap",id:"heap",level:2},{value:"Caratteristiche principali",id:"caratteristiche-principali-1",level:3}];function d(e){const i={code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(i.hr,{}),"\n",(0,l.jsx)(i.h2,{id:"differenze-chiave",children:"Differenze chiave"}),"\n",(0,l.jsxs)(i.table,{children:[(0,l.jsx)(i.thead,{children:(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.th,{children:"Aspetto"}),(0,l.jsx)(i.th,{children:"Stack"}),(0,l.jsx)(i.th,{children:"Heap"})]})}),(0,l.jsxs)(i.tbody,{children:[(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.strong,{children:"Allocazione"})}),(0,l.jsx)(i.td,{children:"Automatica (a compile-time)"}),(0,l.jsx)(i.td,{children:"Dinamica (a runtime)"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.strong,{children:"Gestione"})}),(0,l.jsx)(i.td,{children:"Automatica (scope-based)"}),(0,l.jsx)(i.td,{children:"Manuale (new/delete)"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.strong,{children:"Velocit\xe0"})}),(0,l.jsx)(i.td,{children:"Molto veloce"}),(0,l.jsx)(i.td,{children:"Pi\xf9 lenta"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.strong,{children:"Dimensione"})}),(0,l.jsx)(i.td,{children:"Limitata (tipicamente MB)"}),(0,l.jsx)(i.td,{children:"Molto grande (dipende dal sistema)"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.strong,{children:"Tipi di dati"})}),(0,l.jsx)(i.td,{children:"Variabili locali, parametri"}),(0,l.jsx)(i.td,{children:"Oggetti di vita variabile, grandi strutture dati"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.strong,{children:"Rischi"})}),(0,l.jsx)(i.td,{children:"Stack overflow se esageri"}),(0,l.jsx)(i.td,{children:"Memory leak se non gestito"})]})]})]}),"\n",(0,l.jsx)(i.hr,{}),"\n",(0,l.jsx)(i.h2,{id:"stack",children:"Stack"}),"\n",(0,l.jsx)(i.p,{children:"Lo stack \xe8 una porzione di memoria usata per gestire le chiamate di funzione, variabili locali e il controllo del flusso."}),"\n",(0,l.jsx)(i.p,{children:"Funziona come una pila LIFO (Last In First Out)."}),"\n",(0,l.jsx)(i.h3,{id:"caratteristiche-principali",children:"Caratteristiche principali"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:["\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Allocazione automatica"}),": le variabili locali e i parametri di funzione vengono allocate sullo stack automaticamente quando si entra in una funzione e deallocate quando si esce."]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Gestione automatica della memoria"}),": non serve gestire manualmente la memoria, la deallocazione \xe8 automatica alla fine del blocco."]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Accesso molto rapido"}),": le variabili sono vicine tra loro in memoria, quindi cache-friendly."]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Velocit\xe0"}),": l'allocazione e deallocazione sono molto veloci perch\xe9 avvengono in ordine LIFO."]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Dimensione limitata"}),": la dimensione dello stack \xe8 limitata (tipicamente qualche MB, configurabile), quindi non \xe8 adatto per dati grandi o molti dati dinamici."]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"esempio",children:"Esempio"}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-cpp",children:"void foo() {\r\n    int a = 10;       // allocato nello stack\r\n    int arr[100];     // allocato nello stack (attenzione alla dimensione!)\r\n}\n"})}),"\n",(0,l.jsx)(i.hr,{}),"\n",(0,l.jsx)(i.h2,{id:"heap",children:"Heap"}),"\n",(0,l.jsx)(i.p,{children:"Lo heap \xe8 una porzione di memoria usata per allocazioni dinamiche, cio\xe8 quando si crea memoria a runtime e la si gestisce manualmente."}),"\n",(0,l.jsx)(i.h3,{id:"caratteristiche-principali-1",children:"Caratteristiche principali"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:["\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Allocazione dinamica"}),": la memoria viene allocata con new (o malloc in C) e deallocata con delete (o free)."]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Gestione manuale"}),": devi allocare e deallocare tu esplicitamente la memoria per evitare memory leak."]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Rischio di memory leak"}),": se non deallochi correttamente, la memoria rimane occupata inutilmente."]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Accesso pi\xf9 lento"}),": l'allocazione \xe8 pi\xf9 lenta e l'accesso pu\xf2 essere meno efficiente a causa di frammentazione e minor localit\xe0 spaziale."]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Dimensione molto pi\xf9 grande"}),": \xe8 molto pi\xf9 grande dello stack e permette di allocare grandi blocchi di memoria."]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-cpp",children:"void foo() {\r\n    int* p = new int[100];  // allocazione dinamica sull'heap\r\n    // ... uso p\r\n    delete[] p;             // deallocazione manuale\r\n}\n"})}),"\n",(0,l.jsx)(i.hr,{})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,l.jsx)(i,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>s,x:()=>r});var a=n(6540);const l={},t=a.createContext(l);function s(e){const i=a.useContext(t);return a.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),a.createElement(t.Provider,{value:i},e.children)}}}]);