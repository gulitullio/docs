"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7296],{8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var t=i(6540);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}},9583:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"languages/c-plus-plus/smart-pointer","title":"Smart Pointer","description":"Gli smart pointer sono degli oggetti che gestiscono automaticamente la memoria in linguaggi come C++.","source":"@site/content/languages/c-plus-plus/smart-pointer.md","sourceDirName":"languages/c-plus-plus","slug":"/languages/c-plus-plus/smart-pointer","permalink":"/docs/content/languages/c-plus-plus/smart-pointer","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/content/languages/c-plus-plus/smart-pointer.md","tags":[],"version":"current","frontMatter":{"title":"Smart Pointer"},"sidebar":"tutorialSidebar","previous":{"title":"Return Value Optimization (RVO)","permalink":"/docs/content/languages/c-plus-plus/rvo"},"next":{"title":"Domande conoscitive","permalink":"/docs/content/interview/domande-conoscitive"}}');var r=i(4848),s=i(8453);const a={title:"Smart Pointer"},o=void 0,l={},c=[{value:"Perch\xe9 usare gli smart pointer?",id:"perch\xe9-usare-gli-smart-pointer",level:3},{value:"std::unique_ptr",id:"stdunique_ptr",level:3},{value:"std::shared_ptr",id:"stdshared_ptr",level:3},{value:"std::weak_ptr",id:"stdweak_ptr",level:3}];function d(e){const n={code:"code",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Gli smart pointer sono degli oggetti che gestiscono automaticamente la memoria in linguaggi come C++.\r\nServono per evitare problemi comuni legati alla gestione manuale della memoria, come:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Memory leak (dimenticare di liberare memoria)"}),"\n",(0,r.jsx)(n.li,{children:"Doppi delete (liberare due volte la stessa memoria)"}),"\n",(0,r.jsx)(n.li,{children:"Dangling pointer (puntatori che puntano a memoria gi\xe0 liberata)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Si comportano come normali puntatori, ma quando l\u2019ultimo smart pointer che punta a un certo blocco di memoria viene distrutto o riassegnato, automaticamente libera la memoria."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"perch\xe9-usare-gli-smart-pointer",children:"Perch\xe9 usare gli smart pointer?"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sicurezza"}),": ti aiutano a evitare errori di gestione della memoria"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pulizia del codice"}),": liberano automaticamente la memoria, quindi meno codice per gestirla"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flessibilit\xe0"}),": specialmente i shared_ptr permettono di condividere risorse senza problemi"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"stdunique_ptr",children:"std::unique_ptr"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Unico proprietario della risorsa"}),"\n",(0,r.jsx)(n.li,{children:"Non pu\xf2 essere copiato, solo trasferito (con move)"}),"\n",(0,r.jsxs)(n.li,{children:["Quando ",(0,r.jsx)(n.code,{children:"unique_ptr"})," viene distrutto, distrugge anche la risorsa a cui punta"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'std::unique_ptr<int> p1(new int(5));\r\n// p1 \xe8 l\'unico che "possiede" il puntatore\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"stdshared_ptr",children:"std::shared_ptr"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Permette la condivisione della propriet\xe0 della risorsa"}),"\n",(0,r.jsx)(n.li,{children:"Tiene un conteggio di riferimenti (quanti shared_ptr puntano alla stessa risorsa)"}),"\n",(0,r.jsxs)(n.li,{children:["Quando l\u2019ultimo ",(0,r.jsx)(n.code,{children:"shared_ptr"})," viene distrutto o riassegnato, la risorsa viene liberata."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"std::shared_ptr<int> p1 = std::make_shared<int>(10);\r\nstd::shared_ptr<int> p2 = p1;  // ora ci sono 2 shared_ptr che puntano allo stesso int\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"stdweak_ptr",children:"std::weak_ptr"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Non possiede la risorsa, ma osserva un ",(0,r.jsx)(n.code,{children:"shared_ptr"})," senza aumentarne il conteggio."]}),"\n",(0,r.jsx)(n.li,{children:"Utile per evitare cicli di riferimento che impedirebbero la distruzione degli oggetti."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"std::shared_ptr<int> sp = std::make_shared<int>(42);\r\nstd::weak_ptr<int> wp = sp;  // wp osserva l'oggetto puntato da sp, ma non ne aumenta il conteggio\n"})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);