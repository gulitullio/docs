"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9777],{2456:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>s});const r=JSON.parse('{"id":"architetture/component-based","title":"Component-Based Architecture","description":"E\' un approccio di progettazione del software in cui le funzionalit\xe0 di un sistema non vengono organizzate in lunghe gerarchie di classi (come nell\u2019OOP classica), ma vengono composte tramite unit\xe0 indipendenti chiamate componenti.","source":"@site/content/architetture/component-based.md","sourceDirName":"architetture","slug":"/architetture/component-based","permalink":"/docs/content/architetture/component-based","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/content/architetture/component-based.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Component-Based Architecture","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Layered Architecture (Architettura a livelli)","permalink":"/docs/content/architetture/layer"},"next":{"title":"Event-Driven Architecture (EDA)","permalink":"/docs/content/architetture/event-driven"}}');var t=i(4848),o=i(8453);const a={title:"Component-Based Architecture",sidebar_position:4},l=void 0,c={},s=[{value:"Perch\xe9 usarla",id:"perch\xe9-usarla",level:3},{value:"Quando usarlo",id:"quando-usarlo",level:3},{value:"Come usarla",id:"come-usarla",level:3},{value:"Esempio",id:"esempio",level:3},{value:"Health",id:"health",level:4},{value:"PlayerMovement",id:"playermovement",level:4},{value:"Weapon",id:"weapon",level:4}];function d(e){const n={code:"code",h3:"h3",h4:"h4",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"E' un approccio di progettazione del software in cui le funzionalit\xe0 di un sistema non vengono organizzate in lunghe gerarchie di classi (come nell\u2019OOP classica), ma vengono composte tramite unit\xe0 indipendenti chiamate componenti."}),"\n",(0,t.jsx)(n.p,{children:"Ogni componente:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\xc8 focalizzato su una ",(0,t.jsx)(n.strong,{children:"singola responsabilit\xe0"})," (principio SRP)."]}),"\n",(0,t.jsxs)(n.li,{children:["\xc8 ",(0,t.jsx)(n.strong,{children:"riutilizzabile"})," in contesti diversi."]}),"\n",(0,t.jsxs)(n.li,{children:["\xc8 intercambiabile e ",(0,t.jsx)(n.strong,{children:"indipendente"})," dal resto del codice."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Un esempio pratica potrebbero essere i componenti di Unity:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:'Ogni GameObject \xe8 come un "contenitore" dove i comportamenti sono definiti da componenti (script, renderer, collider, ecc.).'}),"\n",(0,t.jsx)(n.li,{children:"Invece di ereditare da un\u2019unica mega-classe, il GameObject pu\xf2 avere tanti piccoli script che cooperano."}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"perch\xe9-usarla",children:"Perch\xe9 usarla"}),"\n",(0,t.jsx)(n.p,{children:"Rispetto al classico approccio \u201ceredito da Character e poi specializzo in Enemy o Player\u201d:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Maggiore riuso"}),": lo stesso componente \u201cHealth\u201d pu\xf2 essere usato su nemici, giocatori, NPC, torrette..."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Minore accoppiamento"}),": i componenti non dipendono dalla struttura gerarchica delle classi."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Estendibilit\xe0 dinamica"}),": in Unity puoi aggiungere/rimuovere componenti a runtime senza cambiare il codice base."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Facile testing"}),": puoi testare singoli componenti in isolamento."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"In generale in giochi complessi (es. RPG), evita classi da 2000 righe e ti permette di evolvere pi\xf9 facilmente il gameplay."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"quando-usarlo",children:"Quando usarlo"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Se il tuo gioco/programma \xe8 destinato a evolvere nel tempo, con molte nuove feature o comportamenti,"}),"\n",(0,t.jsx)(n.li,{children:"Quando vuoi poter riusare lo stesso comportamento su entit\xe0 diverse senza duplicare codice."}),"\n",(0,t.jsx)(n.li,{children:"Ogni componente \xe8 \u201cplug-and-play\u201d e pu\xf2 essere applicato a qualunque oggetto compatibile."}),"\n",(0,t.jsx)(n.li,{children:"Team diversi possono lavorare su componenti separati senza conflitti sugli stessi file."}),"\n",(0,t.jsx)(n.li,{children:"Se il gameplay prevede aggiungere o rimuovere comportamenti a runtime"}),"\n",(0,t.jsx)(n.li,{children:"L\u2019approccio OOP tradizionale pu\xf2 portare a catene di ereditariet\xe0 complesse (Entity \u2192 Character \u2192 Enemy \u2192 FlyingEnemy \u2192 BossFlyingEnemy) che diventano fragili"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"come-usarla",children:"Come usarla"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Identifica i comportamenti indipendenti (movimento, salute, IA, inventario, ecc.)."}),"\n",(0,t.jsx)(n.li,{children:"Implementa ciascun comportamento come componente autonomo."}),"\n",(0,t.jsx)(n.li,{children:"Associa i componenti all'object che li deve avere."}),"\n",(0,t.jsx)(n.li,{children:"I componenti comunicano tra loro tramite: eventi o interfacce"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"esempio",children:"Esempio"}),"\n",(0,t.jsx)(n.p,{children:"Supponiamo di avere un giocatore con:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Movimento (PlayerMovement)"}),"\n",(0,t.jsx)(n.li,{children:"Sistema di salute (Health)"}),"\n",(0,t.jsx)(n.li,{children:"Arma (Weapon)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"La struttura sar\xe0 la seguente:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Player (GameObject)\r\n \u251c\u2500\u2500 PlayerMovement (script)\r\n \u251c\u2500\u2500 Health (script)\r\n \u251c\u2500\u2500 Weapon (script)\r\n \u251c\u2500\u2500 SpriteRenderer\r\n \u2514\u2500\u2500 Rigidbody2D\n"})}),"\n",(0,t.jsx)(n.p,{children:"In pratica crei un GameObject Player, gli aggiungi i componenti PlayerMovement, Health, Weapon (oltre a collider, rigidbody, ecc.).\r\nI componenti non sono gerarchicamente collegati da ereditariet\xe0: sono indipendenti e collaborano."}),"\n",(0,t.jsx)(n.h4,{id:"health",children:"Health"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class Health : MonoBehaviour\r\n{\r\n    [SerializeField] private int maxHealth = 100;\r\n    private int currentHealth;\r\n\r\n    public System.Action OnDeath;\r\n\r\n    private void Awake()\r\n    {\r\n        currentHealth = maxHealth;\r\n    }\r\n\r\n    public void TakeDamage(int amount)\r\n    {\r\n        currentHealth -= amount;\r\n        if (currentHealth <= 0)\r\n        {\r\n            currentHealth = 0;\r\n            OnDeath?.Invoke();\r\n        }\r\n    }\r\n\r\n    public void Heal(int amount)\r\n    {\r\n        currentHealth = Mathf.Min(currentHealth + amount, maxHealth);\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"playermovement",children:"PlayerMovement"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'[RequireComponent(typeof(Rigidbody2D))]\r\npublic class PlayerMovement : MonoBehaviour\r\n{\r\n    [SerializeField] private float speed = 5f;\r\n    private Rigidbody2D rb;\r\n    private Vector2 input;\r\n\r\n    private void Awake()\r\n    {\r\n        rb = GetComponent<Rigidbody2D>();\r\n    }\r\n\r\n    private void Update()\r\n    {\r\n        input = new Vector2(Input.GetAxisRaw("Horizontal"), Input.GetAxisRaw("Vertical")).normalized;\r\n    }\r\n\r\n    private void FixedUpdate()\r\n    {\r\n        rb.MovePosition(rb.position + input * speed * Time.fixedDeltaTime);\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"weapon",children:"Weapon"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class Weapon : MonoBehaviour\r\n{\r\n    [SerializeField] private GameObject bulletPrefab;\r\n    [SerializeField] private Transform firePoint;\r\n\r\n    void Update()\r\n    {\r\n        if (Input.GetButtonDown("Fire1"))\r\n        {\r\n            Shoot();\r\n        }\r\n    }\r\n\r\n    private void Shoot()\r\n    {\r\n        Instantiate(bulletPrefab, firePoint.position, firePoint.rotation);\r\n    }\r\n}\r\n\n'})})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var r=i(6540);const t={},o=r.createContext(t);function a(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);