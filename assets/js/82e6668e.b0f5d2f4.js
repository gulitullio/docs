"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5657],{8453:(i,n,e)=>{e.d(n,{R:()=>r,x:()=>s});var t=e(6540);const o={},a=t.createContext(o);function r(i){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof i?i(n):{...n,...i}},[n,i])}function s(i){let n;return n=i.disableParentContext?"function"==typeof i.components?i.components(o):i.components||o:r(i.components),t.createElement(a.Provider,{value:n},i.children)}},8917:(i,n,e)=>{e.r(n),e.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"algoritmi/pathfinding","title":"Pathfinding","description":"Il pathfinding \xe8 la tecnica usata per trovare il percorso migliore (o uno percorso ottimale) tra due punti in un ambiente, tipicamente rappresentato da una griglia, un grafo o una mappa.","source":"@site/content/algoritmi/pathfinding.md","sourceDirName":"algoritmi","slug":"/algoritmi/pathfinding","permalink":"/docs/content/algoritmi/pathfinding","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/content/algoritmi/pathfinding.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Pathfinding","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Collision resolution","permalink":"/docs/content/algoritmi/collision-resolution"},"next":{"title":"Versioni","permalink":"/docs/content/languages/c-plus-plus/versions"}}');var o=e(4848),a=e(8453);const r={title:"Pathfinding",sidebar_position:3},s=void 0,l={},c=[{value:"Algoritmi pi\xf9 usati",id:"algoritmi-pi\xf9-usati",level:3},{value:"A* in breve",id:"a-in-breve",level:3}];function d(i){const n={h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...i.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"Il pathfinding \xe8 la tecnica usata per trovare il percorso migliore (o uno percorso ottimale) tra due punti in un ambiente, tipicamente rappresentato da una griglia, un grafo o una mappa.\r\n\xc8 fondamentale in giochi, robotica, AI, navigazione e simulazioni."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Navigazione AI"}),": per far muovere NPC (non-player characters) in modo intelligente nel mondo di gioco, evitando ostacoli."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Ottimizzazione del percorso"}),": per trovare la strada pi\xf9 breve o pi\xf9 efficiente tra punti."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Realismo"}),": migliora il gameplay rendendo il movimento degli NPC pi\xf9 credibile."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Gestione dinamica"}),": adattarsi a cambiamenti della mappa o ostacoli in tempo reale."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"algoritmi-pi\xf9-usati",children:"Algoritmi pi\xf9 usati"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"A* (A star)"}),": cerca il percorso pi\xf9 efficiente usando una combinazione di costo gi\xe0 sostenuto (distanza dal punto di partenza) e una stima del costo residuo (euristica) per arrivare alla destinazione. \xc8 un best-first search informato."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Dijkstra"}),": trova il percorso pi\xf9 breve da un nodo a tutti gli altri, ma non usa euristica quindi \xe8 meno efficiente di A* in molti casi."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"BFS (Breadth-First Search)"}),": trova il percorso pi\xf9 breve in grafi non pesati, ma non \xe8 efficiente su grandi mappe."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"DFS (Depth-First Search)"}),": non garantisce il percorso pi\xf9 breve, spesso usato in esplorazione."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["N.B. Unity ha un sistema built-in di pathfinding chiamato ",(0,o.jsx)(n.strong,{children:"NavMesh"})]}),"\n",(0,o.jsx)(n.h3,{id:"a-in-breve",children:"A* in breve"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Mantiene una open list di nodi da esplorare e una closed list di nodi gi\xe0 esplorati."}),"\n",(0,o.jsx)(n.li,{children:"Calcola il costo totale f(n) = g(n) + h(n), dove:"}),"\n",(0,o.jsx)(n.li,{children:"g(n) = costo dal nodo iniziale al nodo n"}),"\n",(0,o.jsx)(n.li,{children:"h(n) = stima (euristica) dal nodo n al nodo obiettivo"}),"\n",(0,o.jsx)(n.li,{children:"Sceglie di espandere il nodo con il costo totale pi\xf9 basso."}),"\n",(0,o.jsx)(n.li,{children:"Continua finch\xe9 non raggiunge il nodo obiettivo."}),"\n"]})]})}function p(i={}){const{wrapper:n}={...(0,a.R)(),...i.components};return n?(0,o.jsx)(n,{...i,children:(0,o.jsx)(d,{...i})}):d(i)}}}]);