"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3480],{8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>s});var a=r(6540);const t={},o=a.createContext(t);function i(e){const n=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),a.createElement(o.Provider,{value:n},e.children)}},8724:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"design-patterns/strutturali/decorator","title":"Decorator","description":"E\' un pattern strutturale che permette di aggiungere dinamicamente comportamenti o responsabilit\xe0 a un oggetto senza modificare il codice della sua classe originale.","source":"@site/content/design-patterns/strutturali/decorator.md","sourceDirName":"design-patterns/strutturali","slug":"/design-patterns/strutturali/decorator","permalink":"/docs/content/design-patterns/strutturali/decorator","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/content/design-patterns/strutturali/decorator.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Decorator","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Strutturali","permalink":"/docs/content/design-patterns/strutturali/"},"next":{"title":"Adapter (o Wrapper)","permalink":"/docs/content/design-patterns/strutturali/adapter"}}');var t=r(4848),o=r(8453);const i={title:"Decorator",sidebar_position:1},s=void 0,c={},l=[{value:"Quando usarlo \u2705",id:"quando-usarlo-",level:3},{value:"Quando NON usarlo \u274c",id:"quando-non-usarlo-",level:3},{value:"Esempio",id:"esempio",level:2},{value:"Interfaccia componente",id:"interfaccia-componente",level:4},{value:"Componente concreto",id:"componente-concreto",level:4},{value:"Decoratore astratto",id:"decoratore-astratto",level:4},{value:"Decoratore concreto: Scudo",id:"decoratore-concreto-scudo",level:4},{value:"Utilizzo",id:"utilizzo",level:4}];function d(e){const n={br:"br",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["E' un pattern ",(0,t.jsx)(n.strong,{children:"strutturale"})," che permette di aggiungere dinamicamente comportamenti o responsabilit\xe0 a un oggetto ",(0,t.jsx)(n.strong,{children:"senza modificare il codice della sua classe originale"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Si ottiene avvolgendo (wrapping) l'oggetto in un altro oggetto che implementa la stessa interfaccia.",(0,t.jsx)(n.br,{}),"\n","L'idea \xe8 simile alle ",(0,t.jsx)(n.strong,{children:"matrioske"}),': ogni decoratore pu\xf2 aggiungere logica extra e passare le chiamate all\'oggetto "interno".']}),"\n",(0,t.jsx)(n.p,{children:"La struttura \xe8 la seguente:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Component"}),": interfaccia o classe astratta base."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ConcreteComponent"}),": implementazione concreta del componente."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Decorator"}),": classe astratta che implementa ",(0,t.jsx)(n.code,{children:"Component"})," e contiene un riferimento a un ",(0,t.jsx)(n.code,{children:"Component"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ConcreteDecorator"}),": aggiunge nuove funzionalit\xe0."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"quando-usarlo-",children:"Quando usarlo \u2705"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Vuoi aggiungere responsabilit\xe0 a un oggetto senza modificare il suo codice."}),"\n",(0,t.jsx)(n.li,{children:"Vuoi combinare comportamenti in modo flessibile e dinamico."}),"\n",(0,t.jsx)(n.li,{children:"Vuoi evitare una gerarchia di classi troppo complessa a causa di estensioni multiple."}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"quando-non-usarlo-",children:"Quando NON usarlo \u274c"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["La logica extra pu\xf2 essere gestita pi\xf9 semplicemente con ",(0,t.jsx)(n.em,{children:"composition"})," o ",(0,t.jsx)(n.em,{children:"strategy"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Il sistema ha gi\xe0 molte istanze annidate e il debugging diventerebbe difficile."}),"\n",(0,t.jsx)(n.li,{children:"Le performance sono critiche e il wrapping aggiungerebbe overhead inutile."}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"esempio",children:"Esempio"}),"\n",(0,t.jsxs)(n.p,{children:["Supponiamo di avere un personaggio in un gioco che pu\xf2 subire danni.",(0,t.jsx)(n.br,{}),"\n","Con il Decorator possiamo aggiungere dinamicamente effetti (scudi, potenziamenti, ecc.) senza modificare il codice di base."]}),"\n",(0,t.jsx)(n.h4,{id:"interfaccia-componente",children:"Interfaccia componente"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public interface IDamageable\r\n{\r\n    void TakeDamage(int amount);\r\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"componente-concreto",children:"Componente concreto"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class Player : MonoBehaviour, IDamageable\r\n{\r\n    public int Health = 100;\r\n\r\n    public void TakeDamage(int amount)\r\n    {\r\n        Health -= amount;\r\n        Debug.Log($"Player ha {Health} HP rimanenti.");\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"decoratore-astratto",children:"Decoratore astratto"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public abstract class DamageableDecorator : IDamageable\r\n{\r\n    protected IDamageable _wrapped;\r\n\r\n    public DamageableDecorator(IDamageable wrapped)\r\n    {\r\n        _wrapped = wrapped;\r\n    }\r\n\r\n    public virtual void TakeDamage(int amount)\r\n    {\r\n        _wrapped.TakeDamage(amount);\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"decoratore-concreto-scudo",children:"Decoratore concreto: Scudo"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class ShieldDecorator : DamageableDecorator\r\n{\r\n    private int _shieldStrength;\r\n\r\n    public ShieldDecorator(IDamageable wrapped, int shieldStrength) : base(wrapped)\r\n    {\r\n        _shieldStrength = shieldStrength;\r\n    }\r\n\r\n    public override void TakeDamage(int amount)\r\n    {\r\n        if (_shieldStrength > 0)\r\n        {\r\n            int absorbed = Mathf.Min(amount, _shieldStrength);\r\n            _shieldStrength -= absorbed;\r\n            amount -= absorbed;\r\n            Debug.Log($"Scudo assorbe {absorbed} danni. Scudo rimanente: {_shieldStrength}");\r\n        }\r\n\r\n        if (amount > 0)\r\n        {\r\n            base.TakeDamage(amount);\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"utilizzo",children:"Utilizzo"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class GameController : MonoBehaviour\r\n{\r\n    void Start()\r\n    {\r\n        Player player = new Player();\r\n        IDamageable decoratedPlayer = new ShieldDecorator(player, 20);\r\n\r\n        decoratedPlayer.TakeDamage(10); // Scudo assorbe 10\r\n        decoratedPlayer.TakeDamage(15); // Scudo assorbe 10, player prende 5\r\n    }\r\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);